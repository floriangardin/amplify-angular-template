import { Component, signal, input, OnInit, ElementRef, ViewChild, output, computed, effect } from '@angular/core';
import { marked } from 'marked';
import { CommonModule, NgClass } from '@angular/common';
import { linkifyHtml, linkifyText, LinkSpec } from '../utils/linkify-terms';

// --- marked: force classes on list tags (minimal) ---
const renderer = new marked.Renderer();
renderer.list = (body, ordered, start) => {
  const tag = ordered ? 'ol' : 'ul';
  const cls = ordered ? 'list-decimal' : 'list-disc';
  const startAttr = ordered && start !== 1 ? ` start="${start}"` : '';
  return `<${tag} class="${cls}"${startAttr}>${body}</${tag}>`;
};
marked.use({ renderer });

@Component({
  selector: 'app-editable-text',
  standalone: true,
  imports: [CommonModule, NgClass],
  template: `
    <div class="editable-wrapper w-full" 
         [class.editable]="isEditable()" 
         [class.editing]="editing()"
         (click)="onWrapperClick($event)">

      @if(!editing()){
        <ng-container>
          @if(!isMarkdown()){
            <p class="text-value" [ngClass]="contentClass()" [innerHTML]="renderedPlainHtml()"></p>
          }@else{
            <div class="text-value" [ngClass]="contentClass()" [innerHTML]="renderedHtml()"></div>
          }
          @if(isEditable()){
            <button type="button" class="icon-button edit-btn ml-auto" (click)="$event.stopPropagation();startEditing()" aria-label="Edit text">
              <i class="fa fa-pen"></i>
            </button>
          }
        </ng-container>
      }@else{
        <div class="edit-container">
          <textarea
            #textInput
            class="edit-input textarea"
            [value]="draftText()"
            (click)="$event.stopPropagation()"
            (input)="autoResize(textInput); onDraftChange($any($event.target).value)"
            (keydown.escape)="onCancel()"
          ></textarea>
          <button type="button" class="icon-button validate-btn" (click)="$event.stopPropagation();onValidate()" aria-label="Validate edition">
            <i class="fa fa-check"></i>
          </button>
          <button type="button" class="icon-button cancel-btn" (click)="$event.stopPropagation();onCancel()" aria-label="Cancel edition">
            <i class="fa fa-times"></i>
          </button>
        </div>
      }
    </div>
  `,
  styles: [`
    .editable-wrapper { position: relative; display: flex; align-items: center; gap: .5rem; }
    .editable-wrapper.editable { border: 1px dashed #888; padding: .25rem .5rem; border-radius: 4px; }
    .text-value { margin: 0; width: 100%; }
    .text-value.list-disc ul { list-style-type: disc; padding-left: 1.25rem; margin: .5rem 0; }
    .text-value.list-decimal ol { list-style-type: decimal; padding-left: 1.25rem; margin: .5rem 0; }
    .icon-button { background: transparent; border: none; cursor: pointer; color: #555; padding: 2px 4px; line-height: 1; }
    .icon-button:hover { color: #111; }
    .edit-container { display: flex; align-items: stretch; gap: .25rem; width: 100%; }
    .edit-input { flex: 1; padding: 4px 6px; border: 1px solid #aaa; border-radius: 4px; font: inherit; resize: none; overflow-y: hidden; }
    .edit-input.textarea { min-height: 2rem; }
    .validate-btn { color: #1b7f1b; }
    .validate-btn:hover { color: #0e4d0e; }
    .cancel-btn { color: #aa1a1a; }
    .cancel-btn:hover { color: #6d0f0f; }
  `],
  host: {  }
})
export class EditableTextComponent implements OnInit {
  text = input<string>('Editable text');
  contentClass = input<string>('');
  isMarkdown = input<boolean>(true);
  // Optional: map of terms to links to auto-wrap occurrences in the rendered output
  linkTerms = input<Record<string, LinkSpec> | undefined>(undefined);
  // Optional: whether term matching is case-sensitive (default true)
  linkCaseSensitive = input<boolean>(true);
  newText = output<string>();
  // Fired when a term auto-link (generated by linkify) is clicked
  linkClick = output<{ label: string; href: string }>();
  isEditable = input<boolean>(false);
  editing = signal(false);
  displayText = signal<string>('');
  draftText = signal<string>('');
  private originalValue = '';

  renderedHtml = computed(() => {
    if (!this.isMarkdown()) return this.displayText();
    const raw = this.displayText();
    if (!raw) return '';
    const html = marked.parse(raw, { breaks: true }) as string;
  const map = this.linkTerms();
  return map ? linkifyHtml(html, map, this.linkCaseSensitive()) : html;
  });

  renderedPlainHtml = computed(() => {
    if (this.isMarkdown()) return this.renderedHtml();
    const raw = this.displayText();
  const map = this.linkTerms();
  return map ? linkifyText(raw, map, this.linkCaseSensitive()) : (raw || '');
  });

  @ViewChild('textInput') set textInputSetter(ref: ElementRef<HTMLTextAreaElement> | undefined) {
    const el = ref?.nativeElement;
    if (el) this.autoResize(el);
  }

  ngOnInit() {
    this.displayText.set(this.text());
  }

  constructor(){
    // Keep displayText synced with the input text except while actively editing
    effect(() => {
      const incoming = this.text();
      if(!this.editing()) {
        this.displayText.set(incoming);
      }
    });
  }

  autoResize(el: HTMLTextAreaElement | null) {
    if (!el) return;
    el.style.height = 'auto';
    el.style.height = `${el.scrollHeight}px`;
  }

  startEditing() {
    if (!this.isEditable()) return;
    const current = this.displayText();
    this.originalValue = current;
    this.draftText.set(current);
    this.editing.set(true);
  }

  onDraftChange(value: string) {
    this.draftText.set(value);
  }

  onValidate() {
    this.validate();
    this.displayText.set(this.draftText());
    this.editing.set(false);
  }

  onCancel() {
    this.draftText.set(this.originalValue);
    this.editing.set(false);
  }

  validate() {
    this.newText.emit(this.draftText());
  }

  // Capture clicks on auto-linked <a> tags to let parent handle (e.g., open popup)
  onWrapperClick(event: MouseEvent) {
    const target = event.target as HTMLElement | null;
    if (!target) return;
    // Walk up to find the nearest anchor with class 'auto-link'
    let el: HTMLElement | null = target;
    while (el && el !== (event.currentTarget as HTMLElement)) {
      if (el.tagName === 'A' && el.classList.contains('auto-link')) {
        event.preventDefault();
        event.stopPropagation();
        const a = el as HTMLAnchorElement;
        const label = (a.textContent || '').trim();
        const href = a.href;
        this.linkClick.emit({ label, href });
        return;
      }
      el = el.parentElement;
    }
  }
}
